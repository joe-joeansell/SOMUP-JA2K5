I am creating a project in p5.js that will display visuals on screen in response to a piece of music. I want to have a json file which tells the project to change the visuals at certain times during the music. How could I control this within p5.js?

Great idea, Joe! You can absolutely drive visuals from a JSON timeline in p5.js. There are two solid ways to do it:

1. **Use the p5.sound library’s cue system** (most robust, stays locked to the audio’s playback time).
2. **Manually poll the audio time** and trigger events when you pass each timestamp.

Below are both approaches with a JSON format and full examples.

---

## 1) JSON Format Example

Create a `timeline.json` that lists changes by time (in seconds) and the parameters to change:
{

  "cues": [

    { "time": 0.0,  "action": "bg",       "params": { "color": "#0d1321" } },

    { "time": 5.2,  "action": "shape",    "params": { "type": "circle", "size": 80 } },

    { "time": 12.0, "action": "bg",       "params": { "color": "#1d2d50" } },

    { "time": 20.5, "action": "shape",    "params": { "type": "square", "size": 120 } },

    { "time": 32.0, "action": "effect",   "params": { "name": "pulse", "speed": 0.8 } }

  ]

}
You can add any fields you like—just keep a consistent schema.

## 2) Using `p5.sound` cues (recommended)

If you’re using the **p5.sound** library, `p5.SoundFile.addCue()` lets you schedule callbacks at precise audio times (the same mechanism DAWs use for markers). This keeps everything synced even if the audio is paused or scrubbed.

> **Make sure you include p5.sound** in your HTML:

`https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js</script>`

`https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/addons/p5.sound.min.js</script>`

Full example
`let song;`
`let timeline; // JSON data`
`let bgColor = '#000000';`
`let shapeType = 'circle';`
`let shapeSize = 60;`
`let effect = null;`

`function preload() {`
  `// Load audio and JSON before setup`
  `song = loadSound('assets/music.mp3');   // your music file`
  `timeline = loadJSON('assets/timeline.json'); // the JSON example above`
`}`

`function setup() {`
  `createCanvas(800, 600);`
  `noStroke();`

  `// Add cues based on the timeline`
  `if (timeline && timeline.cues) {`
    `timeline.cues.forEach((cue, index) => {`
      `// Pass the cue object to the callback`
      `song.addCue(cue.time, onCue, cue);`
    `});`
  `}`

  `// Start on user gesture (required by browsers)`
  `const btn = createButton('Play / Pause');`
  `btn.mousePressed(() => {`
    `if (song.isPlaying()) {`
      `song.pause();`
    `} else {`
      `song.play();`
    `}`
  `});`
`}`

`function onCue(cue) {`
  `// Handle each action type`
  `switch (cue.action) {`
    `case 'bg':`
      `bgColor = cue.params?.color ?? bgColor;`
      `break;`
    `case 'shape':`
      `shapeType = cue.params?.type ?? shapeType;`
      `shapeSize = cue.params?.size ?? shapeSize;`
      `break;`
    `case 'effect':`
      `effect = cue.params ?? effect;`
      `break;`
    `default:`
      `// Unknown action; ignore or log`
      `console.warn('Unknown cue action:', cue);`
  `}`
`}`

`function draw() {`
  `// Background`
  `background(bgColor);`

  `// Optional: visual effect driven by time`
  `if (effect?.name === 'pulse') {`
    `const t = millis() / 1000;`
    `const k = 0.5 + 0.5 * sin(TWO_PI * (effect.speed ?? 1.0) * t);`
    `push();`
    `fill(255, 255 * k);`
    `rect(0, height - 10, width * k, 10);`
    `pop();`
  `}`

  `// Draw the primary shape`
  `push();`
  `fill('#e0fbfc');`
  `const x = width / 2;`
  `const y = height / 2;`
  `const s = shapeSize;`

  `if (shapeType === 'circle') {`
    `circle(x, y, s);`
  `} else if (shapeType === 'square') {`
    `rectMode(CENTER);`
    `square(x, y, s);`
  `} else if (shapeType === 'triangle') {`
    `triangle(x, y - s / 2, x - s / 2, y + s / 2, x + s / 2, y + s / 2);`
  `}`
  `pop();`

  `// (Optional) draw current time for debugging`
  `if (song) {`
    `const t = nf(song.currentTime(), 1, 2);`
    `fill(255);`
    `textSize(14);`
    `text(`Time: ${t}s`, 10, 20);`
  `}`
`}`
### Why this is good
- **Accurate sync**: `addCue()` uses the audio’s internal clock.
- **Pause/Resume-friendly**: Cues still fire at the right times after pausing.
- **Clean structure**: JSON describes _what_ should happen; code describes _how_.
## 3) Manual scheduler (without p5.sound)

If you’re not using p5.sound, you can still schedule by reading timestamps and comparing to the current time. You’ll need an audio element and to query its `currentTime`.
`assets/music.mp3</audio>`

`https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js</script>`

`let audioEl;`
`let timeline;`
`let nextCueIndex = 0;`
`let bgColor = '#000';`
`let shapeType = 'circle';`
`let shapeSize = 60;`
  
`function preload() {`
  `timeline = loadJSON('assets/timeline.json');`
`}`

`function setup() {`
  `createCanvas(800, 600);`
  `audioEl = document.getElementById('player');`

  `// Sort cues by time (important if the JSON isn’t already sorted)`
  `timeline.cues.sort((a, b) => a.time - b.time);`

  `// Reset when user seeks`
  `audioEl.addEventListener('seeked', () => {`
    `// Move pointer to the first cue after the new time`
    `const t = audioEl.currentTime;`
    `nextCueIndex = timeline.cues.findIndex(cue => cue.time > t);`
    `if (nextCueIndex === -1) nextCueIndex = timeline.cues.length;`
  `});`
`}`

`function draw() {`
  `background(bgColor);`
  
  `// Trigger cues when currentTime passes cue time`
  `const t = audioEl.currentTime;`

  `while (`
    `nextCueIndex < timeline.cues.length &&`
    `t >= timeline.cues[nextCueIndex].time`
  `) {`
    `const cue = timeline.cues[nextCueIndex];`
    `triggerCue(cue);`
    `nextCueIndex++;`
  `}`

  `// Draw shape`
  `fill('#e0fbfc');`
  `noStroke();`
  `const x = width / 2, y = height / 2;`
  
  `if (shapeType === 'circle') circle(x, y, shapeSize);`
  `else if (shapeType === 'square') { rectMode(CENTER); square(x, y, shapeSize); }`
`}`

`function triggerCue(cue) {`
  `switch (cue.action) {`
    `case 'bg':`
      `bgColor = cue.params?.color ?? bgColor;`
      `break;`
    `case 'shape':`
      `shapeType = cue.params?.type ?? shapeType;`
      `shapeSize = cue.params?.size ?? shapeSize;`
      `break;`
    `// add more actions as needed`
  `}`
`}`
**Notes**

- This method works fine, but won’t auto-handle pause/resume or tempo changes as precisely as `addCue`.
- If the user seeks backward, you may want to _replay_ cues or recompute state based on the last cue before the new time.

---
## Practical Tips

- **Sorting**: Always sort cues by time to avoid surprises.
- **Idempotency**: Ensure that each cue only fires once. The cue system handles this; manual polling must track it.
- **State vs transient actions**:
    - For **state changes** (background color, shape type), store the latest state and draw from it.
    - For **transient effects** (particles, one-shot flashes), trigger them and manage their lifetime separately.
- **Seek behavior**: If users can scrub the audio, decide whether to:
    - Recompute state using the last cue before the new time, or
    - Replay all cues up to the new time (can be expensive).
- **Performance**: If many cues happen in quick succession, batch updates or minimize expensive work in the cue callback.

---

## Optional: Debounce rapid cues

If your JSON has many events clustered together, debounce visual changes to avoid flicker:
`let lastCueTime = -Infinity;`

`function onCue(cue) {`
  `const now = song.currentTime();`
  `if (now - lastCueTime < 0.05) return; // ignore cues within 50ms`
  `lastCueTime = now;`
  `// apply cue...`
`}`
## Want me to tailor this to your piece?

If you share:

- Your current JSON structure,
- The actions you want (e.g., color palettes, shapes, camera moves),
- Whether you’re already using p5.sound,

…I can adapt the code to your exact setup and help you validate sync and performance with your track.